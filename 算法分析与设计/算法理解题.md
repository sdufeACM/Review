##### 算法理解题

###### #1 数字三角形

- 给定一个数字三角形，从顶至底有多条路径，每一步可沿左斜线向下或沿右斜线向下，路径所经过的数字之和为路径得分，请求出最小路径得分和相应路径。

- 动态规划

  ```cpp
  for(int i = n - 1; i >= 1; i++)
      for(int j = 1; j <= i; j++)
          dp[i][j] = min(dp[i + 1][j],dp[i + 1][j + 1]) + a[i][j];
  ```

  

###### #2 背包问题

- 部分背包问题

  - 物品可分
    - 首先计算出每个物体的单位价值（v/w），然后从大到小排序。按照排好的顺序选择物品放入背包，由于物品可以部分装入，所以装完后背包的重量一定为c


  ```cpp
  // a[] 各个物品
  // ans 最大价值
  // c 当前容量
  sort(a);
  c = W;
  for( i = 1; i <= n; i++){
      if(c < w[i]) break;
      c -= w[i];
      ans += v[i];
  }
  if(i <= n) ans += (c/w[i]) * v[i];
  ```

  

- 01背包

  - 物品不可分，只能选一次

  - 动态规划

    ```cpp
    // f[i] 表示容量为i时最大价值
    for(int i = 1;i <= n; i++){
        for(int j = W; j >= w[i]; j--)
            f[j] = max(f[j],f[j - w[i]] + v[i]);
    }
    return f[V];
    ```

- 完全背包

  - 物品不可分，每个物品无数个
  - dp

  ```cpp
  // f[i] 表示容量为i时最大价值
  for(int i = 1;i <= n; i++){
      for(int j = w[j]; j <= W; j++)
          f[j] = max(f[j],f[j - w[i]] + v[i]);
  }
  return f[V];
  ```

###### #3婚姻稳定问题

- 当前有N位男生和N位女生最后要组成稳定的婚姻家庭，过程开始之前男生和女生在各自的心目中都按照喜爱程度对N位异性有了各自的排序，男生和女生结婚后，对于每一对男生女生，不会出现比起当前匹配的伴侣互相更喜爱的一对男生女生，即可认为婚姻是稳定的。
- 做法：
  - 先对所有男士进行落选标记，称其为自由男。当存在自由男时，进行以下操作：
  - 每一位自由男在所有尚未拒绝她的女士中选择一位被他排名最优先的女士；
  - 每一位女士将正在追求她的自由男与其当前男友进行比较，选择其中排名优先的男士作为其男友，即若自由男优于当前男友，则抛弃前男友；否则保留其男友，拒绝自由男。
  - 若某男士被其女友抛弃，重新变成自由男。

###### #4哈夫曼编码

- 假设有一个字符串 "abracadabra"，我们来求解它的哈夫曼编码。

- 统计字符频率

  - 遍历字符串，统计每个字符出现的次数，得到以下频率表：

    ```js
    a: 5
    b: 2
    r: 2
    c: 1
    d: 1
    
    ```

  - 构建哈夫曼树：

    - 创建叶子节点：根据字符频率创建与字符对应的叶子节点。
    - 构建哈夫曼树：重复以下步骤直到只剩下一个节点：
      - 从频率表中选择两个频率最低的节点。
      - 创建一个新的父节点，频率为这两个节点的频率之和。
      - 将选中的两个节点作为新节点的左右子节点。
      - 将新节点加入频率表。

  - 分配编码：

    - 从根节点出发，沿着左子树路径标记为0，沿着右子树路径标记为1。
    - 对于每个叶子节点，记录从根节点到该叶子节点的路径表示的编码。

###### #5给定网络G，求最大流、最小割、求最短路

- 最大流
  - 简单来说就是水流从一个源点s通过很多路径，经过很多点，到达汇点t，问你最多能有多少水能够到达t点。
  - ![网络流——最大流（全）_C语言](https://s2.51cto.com/images/blog/202106/10/784ef6d637b5a551114ec4dae7368693.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184)
  - 从s到t经过若干个点，若干条边，每一条边的水流都不能超过边权值（可以小于等于但不能大于），所以该图的最大流就是10+22+45=77。
  - 加反向边
- 最小割
  - 最小割 = 最大流

- 最短路
  - 

###### #6 矩阵连乘

- 给定N个矩阵${A_1,A_2,A_3..... A_n}$ 其中 $A_i$ 和 $A_{i+1}$ 可以相乘，其中$A_i$ 的维度是$p[i-1] \times p[i]$如何确定矩阵连乘的计算次序，使得按照此次序计算该矩阵连乘所需要的数乘次数最少？
- $m[i][j]$ 表示从$A_i$ 到 $A_j$ 区间内最少乘的次数，枚举$k(i \textless k \textless j)$ 
- $m[i][j] = max(m[i][j],m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j])$

###### #7嵌套矩形

- 有n个矩形，每个矩形可以用a,b来描述，表示长和宽。矩形$X(a,b)$可以嵌套在矩形$Y(c,d)$中当且仅当$a<c,b<d$或者$b<c,a<d$（相当于旋转$X90$度）你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。

- DAG上的dp

  - 先对矩形排序，长优先，宽次之，小到大 

  - 然后跑dp

    ```cpp
    for(int i = 1;i < n; i++)
        for(int j = i + 1; j <= n; j++)
            if(a[i].x <a[j].x && a[i].y < a[j].y){
                if(dp[j] < 1 + dp[i]){
                    dp[j] = 1 + dp[i];
                    pre[j] = i; // 存储次序
                }
            }
    ```

###### #8任务安排

- $S=\{1,2,......,n\}$ 个任务，$F = \{[S_i,F_i]\}$ 为任务的开始时间和结束时间
- 求最大相容集合，如何选择任务，才能执行最多的任务。
- 每次选$F_i$ 最小的活动，也就是结束时间最小的活动，使能够余下更多的时间选择更多的活动。

###### #9区间调度问题

- 不带权
  - 跟任务安排一样
- 带权
  - 先按照结束时间非降序排序 
  - 定义$p[i]$ 与任务i相容的最大下标
  - $opt[i]$ 前i个任务安排的最大权值
    - 如果 选择第i个，那么他一定是他前$p[i]$个任务的最优解+$w[i]$ 即$opt[i] = opt[p[i]] + w[i]$ 
    - 如果不选，就是前 $i-1$ 个任务的最优解，$opt[i] = opt[i - 1]$ 
  - $opt[i] = max(opt[i - 1], opt[p[i]] + w[i])$

###### #10硬币问题

- 给你一个数组$coins[]$ 表示不同面额的硬币，以及一个$amount$ 表示总金额，计算凑成总金额的最少硬币个数，硬币数量无限
  - 本质是背包问题
  - $ans[j]=min(ans[j],ans[j-v[i]]+1)$

###### #11素数筛法

1.线性筛法

https://www.jianshu.com/p/f16d318efe9b

线性筛是用当前遍历到的数字i，去乘以已经在素数表中的素数。

基本思想
当前数字是$n=p1^a * p2^b * p3^c(p1< p2 < p3且均为素数)$，一次循环筛除小于等于p1的素数乘以n得到的数。比如p1之前有pi,pj和pk三个素数，则此次循环筛掉`pi*n,pj*n,pk*n和p1*n` ，实现见代码的标注一，prime 里的素数都是升序排列的，break时的`prime[j]` 就是这里的p1。

优点：没有重复筛同一个数

>原因：按照一个数的最小素因子筛选，比如6只按2筛去，这样的筛法是线性的，不会出现每一个合数被不同的质数筛掉。
>而prime数组是从小到大的，所以只需要遍历即可，这样就可以实现当`i % prime[j]!=0`时，说明`prime[j]<i 的最小质数`，当`i%prime[j]=0`时，说明此时`prime[j]=i的最小质数`



```cpp
//线性筛法->适用于一定范围的元素的筛选，时间复杂度O(n)
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
	         //primes[j]是i的最小质因子，不用再筛了
        }
    }
}

```

2.埃式筛

埃氏筛法利用了一个素数的倍数一定不是素数、任何一个合数可以表示成一个素数和另一个数乘积的性质。

对于一定的范围，先假定它们都是质数，然后从2（显然是素数）开始，先判断如果是素数，把它在范围内的倍数乘积都筛去（是合数），以此类推循环至 sqrt(n) 即可。

时间复杂度为$O(n \log_{e}{(\log_{e}{n})})$	

这里引入一个数学定理–唯一分解定理，也是算术基本定理

> 算术基本定理可表述为：任何一个大于 1 的自然数N, 如果 N 不为质数，那么 N 可以唯一分解成有限个质数的乘积—-唯一分解定义百度百科

```cpp
const int MAX = 1000005;
bool prime[MAX];
void init()//素数筛
{
	memset(prime,true, prime);
	for(int i=2; i*i<MAX; i++) 
    {
		if(prime[i]) 
        {//是素数 
			for(int j=i*2; j<MAX; j+=i)//从2倍开始，n倍 
				prime[j]=false;//各个倍数 
		}
	}
} 
```

###### #12凸包

**解一：穷举法（蛮力法）**

[时间复杂度](https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020)：O(n³）。  
思路：两点确定一条直线，如果剩余的其它点都在这条直线的同一侧，则这两个点是凸包上的点，否则就不是。  
步骤：

1.  将点集里面的所有点两两配对，组成 n(n-1)/2 条直线。
2.  对于每条直线，再检查剩余的 (n-2) 个点是否在直线的同一侧。

如何判断一个点 p3 是在直线 p1p2 的左边还是右边呢？（坐标：p1(x1,y1)，p2(x2,y2)，p3(x3,y3)）

![](https://keriyar-images.oss-cn-qingdao.aliyuncs.com/img/202407011739950.png)


当上式结果为正时，p3 在直线 p1p2 的左侧；当结果为负时，p3 在直线 p1p2 的右边。

**解二：分治法**

时间复杂度：O(n㏒n)。  
思路：应用分治法思想，把一个大问题分成几个结构相同的子问题，把子问题再分成几个更小的子问题……。然后我们就能用递归的方法，分别求这些子问题的解。最后把每个子问题的解 “组装” 成原来大问题的解。  
步骤：

1.  把所有的点都放在二维坐标系里面。那么横坐标最小和最大的两个点 P1 和 Pn 一定是凸包上的点（为什么呢？用反证法很容易证明，这里不详讲）。直线 P1Pn 把点集分成了两部分，即 X 轴上面和下面两部分，分别叫做上包和下包。
2.  对上包：求距离直线 P1Pn 最远的点，即下图中的点 Pmax 。
3.  作直线 P1Pmax 、PnPmax，把直线 P1Pmax 左侧的点当成是上包，把直线 PnPmax 右侧的点也当成是上包。
4.  重复步骤 2、3。
5.  对下包也作类似操作。

![](https://keriyar-images.oss-cn-qingdao.aliyuncs.com/img/202407011739967.jpeg)


然而怎么求距离某直线最远的点呢？我们还是用到解一中的公式：  

![](https://keriyar-images.oss-cn-qingdao.aliyuncs.com/img/202407011739950.png)


设有一个点 P3 和直线 P1P2 。（坐标：p1(x1,y1)，p2(x2,y2)，p3(x3,y3)）  
对上式的结果取绝对值，绝对值越大，则距离直线越远。

注意：在步骤一，如果横坐标最小的点不止一个，那么这几个点都是凸包上的点，此时上包和下包的划分就有点不同了，需要注意。

**解三：Jarvis 步进法**

时间复杂度：O(nH)。（其中 n 是点的总个数，H 是凸包上的点的个数）  
思路：

*   纵坐标最小的那个点一定是凸包上的点，例如图上的 P0。
*   从 P0 开始，按逆时针的方向，逐个找凸包上的点，每前进一步找到一个点，所以叫作步进法。
*   怎么找下一个点呢？利用夹角。假设现在已经找到 {P0，P1，P2} 了，要找下一个点：剩下的点分别和 P2 组成向量，设这个向量与向量 P1P2 的夹角为 β 。当 β 最小时就是所要求的下一个点了，此处为 P3 。

![](https://keriyar-images.oss-cn-qingdao.aliyuncs.com/img/202407011739964.jpeg)

注意：

1.  找第二个点 P1 时，因为已经找到的只有 P0 一个点，所以向量只能和水平线作夹角 α，当 α 最小时求得第二个点。
2.  共线情况：如果直线 P2P3 上还有一个点 P4，即三个点共线，此时由向量 P2P3 和向量 P2P4 产生的两个 β 是相同的。我们应该把 P3、P4 都当做凸包上的点，并且把距离 P2 最远的那个点（即图中的 P4）作为最后搜索到的点，继续找它的下一个连接点。

**解四：Graham 扫描法**

时间复杂度：O(n㏒n)  
思路：Graham 扫描的思想和 Jarris 步进法类似，也是先找到凸包上的一个点，然后从那个点开始按逆时针方向逐个找凸包上的点，但它不是利用夹角。  

![](https://keriyar-images.oss-cn-qingdao.aliyuncs.com/img/202407011739975.jpeg)


步骤：

1.  把所有点放在二维坐标系中，则纵坐标最小的点一定是凸包上的点，如图中的 P0。
2.  把所有点的坐标平移一下，使 P0 作为原点，如上图。
3.  计算各个点相对于 P0 的幅角 α ，按从小到大的顺序对各个点排序。当 α 相同时，距离 P0 比较近的排在前面。例如上图得到的结果为 P1，P2，P3，P4，P5，P6，P7，P8。我们由几何知识可以知道，结果中第一个点 P1 和最后一个点 P8 一定是凸包上的点。  
    **（以上是准备步骤，以下开始求凸包）**  
    以上，我们已经知道了凸包上的第一个点 P0 和第二个点 P1，我们把它们放在栈里面。现在从步骤 3 求得的那个结果里，把 P1 后面的那个点拿出来做**当前点**，即 P2 。接下来开始找第三个点：
4.  连接 P0 和栈顶的那个点，得到直线 L 。看**当前点**是在直线 L 的右边还是左边。如果在直线的右边就执行步骤 5；如果在直线上，或者在直线的左边就执行步骤 6。
5.  如果在右边，则栈顶的那个元素不是凸包上的点，把栈顶元素出栈。执行步骤 4。
6.  当前点是凸包上的点，把它压入栈，执行步骤 7。
7.  检查当前的点 P2 是不是步骤 3 那个结果的最后一个元素。是最后一个元素的话就结束。如果不是的话就把 P2 后面那个点做当前点，返回步骤 4。

最后，栈中的元素就是凸包上的点了。  
以下为用 Graham 扫描法动态求解的过程：  

![](https://keriyar-images.oss-cn-qingdao.aliyuncs.com/img/202407011739996.gif)

**解五：Melkman 算法**

![](https://keriyar-images.oss-cn-qingdao.aliyuncs.com/img/202407011739009.png)
